{
  "name": "pop-has",
  "version": "1.0.0",
  "description": "Polymorphic has operator for finding whether a collection contains an equivalent value",
  "main": "pop-has.js",
  "directories": {
    "test": "test"
  },
  "scripts": {
    "test": "jasminum test"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/kriskowal/pop-has.git"
  },
  "keywords": [
    "pop",
    "polymoprhic",
    "operator",
    "has"
  ],
  "author": {
    "name": "Kris Kowal",
    "email": "kris@cixar.com"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/kriskowal/pop-has/issues"
  },
  "homepage": "https://github.com/kriskowal/pop-has",
  "devDependencies": {
    "jasminum": "^2.0.5"
  },
  "dependencies": {
    "pop-equals": "^1.0.0"
  },
  "readme": "\n# Has\n\nThis JavaScript package exports a has operator that accepts JavaScript objects,\narrays, and collections and returns whether the object contains an equivalent\nvalue.\n\n```\n$ npm install --save pop-has\n```\n\n```js\nvar has = require(\"pop-has/object-has\");\nexpect(has([1, 2, 3], 2)).toBe(true);\nexpect(has({a: 10}), 10).toBe(true);\nexpect(has(new Set([10]), 10)).toBe(true);\nepxect(has([[1], [2], [3]], [2])).toBe(true);\n```\n\nThe has operator accepts an object, a sought value, and an optional alternate\nequality operator.\nBy default, `has` uses `pop-equals` to determine whether values are equivalent.\nThus, you can alternately use an identity function or whatever you find\nsuitable for determining equivalence.\n\n```js\nfunction is(x, y) {\n    // The latter term is for NaN is NaN\n    return x === y || (x !== x && y !== y);\n}\nexpect(has([{}], {}, is)).toBe(false);\nexpect(has([1, 2, NaN], NaN, is)).toBe(true);\n```\n\nThis operator can be safely used on large sparse arrays since it uses a for/in\nloop with ownership checks on arrays and objects by default.\nThus, it is also suitable for searching values of the owned properties of an\nobject.\n\n## Polymorphic operator\n\nA well-planned system of objects is beautiful: a system where every meaningful\nmethod for an object has been anticipated in the design.\nInevitably, another layer of architecture introduces a new concept and with it\nthe temptation to monkey-patch, dunk-punch, or otherwise cover-up the omission.\nBut reaching backward in time, up through the layers of architecture doesn't\nalways compose well, when different levels introduce concepts of the same name\nbut distinct behavior.\n\nA polymorphic operator is a function that accepts as its first argument an\nobject and varies its behavior depending on its type.\nSuch an operator has the benefit of covering for the types from higher layers of\narchitecture, but defers to the eponymous method name of types yet to be\ndefined.\n\nThe has operator delegates to the has method of any object that implements it.\nThat method will receive the sought value and the appropriate equals operator.\n\n## License and Copyright\n\nCopyright (c) 2015 Kristopher Michael Kowal and contributors.\nAll rights reserved.\nMIT License\n\n",
  "readmeFilename": "README.md",
  "_id": "pop-has@1.0.0",
  "_from": "pop-has@^1.0.0"
}
