{
  "name": "pop-arrayify",
  "version": "1.0.0",
  "description": "Transforms various collections into arrays by whatever means they support",
  "main": "index.js",
  "scripts": {
    "test": "jasminum test"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/kriskowal/pop-arrayify.git"
  },
  "keywords": [
    "pop",
    "polymorphic",
    "operator",
    "array",
    "arrayify",
    "coerce"
  ],
  "author": {
    "name": "Kris Kowal",
    "email": "kris@cixar.com"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/kriskowal/pop-arrayify/issues"
  },
  "homepage": "https://github.com/kriskowal/pop-arrayify",
  "devDependencies": {
    "jasminum": "^2.0.6"
  },
  "readme": "\n# Arrayify\n\nThis JavaScript package exports an arrayify operator that accepts various types\nand coerces them into arrays.\n\n-   Falsy values are coerced to an empty array.\n-   Delegates to the `toArray` method of collections that implement that method.\n-   Delegates to the `forEach` method of other collections that implement that\n    method.\n-   Objects that have a length and numbered properties are coerced into an\n    array.\n    Note that passing `arguments` as an argument to arrayify will probably\n    deoptimize the calling function.\n    However, arrayify defends itself from being deoptimized in this fashion by\n    iterating the given object itself.\n-   Throws an exception for all other cases.\n\n## Examples\n\nInstall\n\n```\nnpm install --save pop-arrayify\n```\n\nImport the pop-arrayify module.\n\n```js\n\"use strict\";\nvar arrayify = require(\"pop-arrayify\");\n```\n\nCopies arrays.\n\n```js\nvar array = [1, 2, 3];\nvar arrayed = arrayify(array);\nexpect(arrayed).not.toBe(array);\nexpect(arrayed).toEqual(array);\n```\n\nCopies objects that implement `toArray`.\n\n```js\nvar List = require(\"collections/list\");\nvar list = new List([1, 2, 3]);\nexpect(arrayify(list)).toEqual([1, 2, 3]);\n```\n\nCopies objects that implement (synchronous) `forEach`.\n\n```js\nexpect(arrayify({\n    forEach: function (callback, thisp) {\n        callback.call(thisp, 1);\n        callback.call(thisp, 2);\n        callback.call(thisp, 3);\n    }\n})).toEqual([1, 2, 3]);\n```\n\nCoerces array-like objects:\n\n```js\nexpect(arrayify({\n    length: 3,\n    0: 1,\n    1: 2,\n    2: 3\n})).toEqual([1, 2, 3]);\n```\n\nCoerces falsy values to empty arrays.\n\n```js\nexpect(arrayify(null)).toEqual([]);\n```\n\nSupports no other cases.\n\n```js\nexpect(function () {\n    arrayify({});\n}).toThrow();\n```\n\n## Polymorphic operator\n\nA well-planned system of objects is beautiful: a system where every meaningful\nmethod for an object has been anticipated in the design.\nInevitably, another layer of architecture introduces a new concept and with it\nthe temptation to monkey-patch, dunk-punch, or otherwise cover-up the omission.\nBut reaching backward in time, up through the layers of architecture doesn't\nalways compose well, when different levels introduce concepts of the same name\nbut distinct behavior.\n\nA polymorphic operator is a function that accepts as its first argument an\nobject and varies its behavior depending on its type.\nSuch an operator has the benefit of covering for the types from higher layers of\narchitecture, but defers to the eponymous method name of types yet to be\ndefined.\n\n## Copyright and License\n\nCopyright (c) 2015 Kristopher Michael Kowal and contributors.\nAll rights reserved.\nMIT License.\n\n",
  "readmeFilename": "README.md",
  "_id": "pop-arrayify@1.0.0",
  "_from": "pop-arrayify@^1.0.0"
}
