{
  "name": "pop-clone",
  "version": "1.0.1",
  "description": "A polymorphic clone operator for arbitrary object graphs",
  "main": "pop-clone.js",
  "scripts": {
    "test": "jasminum test"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/kriskowal/pop-clone.git"
  },
  "keywords": [
    "pop",
    "polymorphic",
    "operator",
    "clone"
  ],
  "author": {
    "name": "Kris Kowal",
    "email": "kris@cixar.com"
  },
  "license": "BSD 3-Clause",
  "bugs": {
    "url": "https://github.com/kriskowal/pop-clone/issues"
  },
  "homepage": "https://github.com/kriskowal/pop-clone",
  "dependencies": {
    "mini-map": "^1.0.0",
    "pop-equals": "^1.0.0"
  },
  "devDependencies": {
    "jasminum": "^2.0.6"
  },
  "readme": "\n# Clone\n\nThis JavaScript package exports a deep clone operator that accepts arbitrary\nobject graphs that may include reference cycles.\nThe clone operator delegates to the clone method of any object that implements\nit.\n\n```\n$ npm install --save pop-clone\n```\n\nThe clone method accepts a value or graph of objects and returns a\nreferentially equivalent graph of objects.\n\n-   value\n-   depth, Infinity by default\n-   memo, an optional map, implementing `has` and `get`, suitable for mapping\n    objects to objects.\n\n```js\nvar clone = require(\"pop-clone\");\nvar object = {};\nobject.object = object;\nvar mirror = clone(object);\n```\n\nClone will replicate:\n\n-   values\n-   arrays\n-   objects that inherit directly from `Object.prototype`.\n-   objects that implement `clone(depth, memo)`.\n\nOther values will throw a \"Can't clone\" error.\n\nWhen the clone is finished, the memo will contain the reflection of every object\nin the given graph.\n\n```js\nvar memo = new Map();\nvar graph = {child: {}};\nvar cloned = clone(graph, null, memo);\nexpect(memo.get(graph.child)).toBe(cloned.child);\n```\n\n## Polymorphic operator\n\nA well-planned system of objects is beautiful: a system where every meaningful\nmethod for an object has been anticipated in the design.\nInevitably, another layer of architecture introduces a new concept and with it\nthe temptation to monkey-patch, dunk-punch, or otherwise cover-up the omission.\nBut reaching backward in time, up through the layers of architecture doesn't\nalways compose well, when different levels introduce concepts of the same name\nbut distinct behavior.\n\nA polymorphic operator is a function that accepts as its first argument an\nobject and varies its behavior depending on its type.\nSuch an operator has the benefit of covering for the types from higher layers of\narchitecture, but defers to the eponymous method name of types yet to be\ndefined.\n\nObjects that implement `clone` will receive the remaining depth and a memo.\nIf no memo is provided, the memo will be a MiniMap from the `mini-map` package.\nThe mini map performs well enough for small collections, but consider providing\na more sophisticated map, `Map` or `WeakMap`, for a large object graph.\n\n```js\nvar object = {\n    child: {\n        clone: function (depth, memo) {\n            expect(memo.has(object)).toBe(true);\n            expect(depth).toBe(1);\n            return \"hello\";\n        }\n    }\n};\nvar cloned = clone(object, 2);\nexpect(cloned.child).toBe(\"hello\");\n```\n\n## Copyright and License\n\nThis project has been factored out of Montage Studio's Collections and as such\nretains its copyright and license.\n\nCopyright (c) 2014 Montage Studio, Inc. and contributors.\nBSD 3-Clause License\n\n",
  "readmeFilename": "README.md",
  "_id": "pop-clone@1.0.1",
  "_from": "pop-clone@^1.0.1"
}
