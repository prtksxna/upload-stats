{
  "name": "pop-compare",
  "version": "1.0.0",
  "description": "Polymorphic deep comparison operator for arbitrary values",
  "main": "pop-compare.js",
  "scripts": {
    "test": "jasminum test"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/kriskowal/pop-compare.git"
  },
  "keywords": [
    "pop",
    "polymorphic",
    "operator",
    "compare"
  ],
  "author": {
    "name": "Kris Kowal",
    "email": "kris@cixar.com"
  },
  "license": "3-Clause BSD",
  "bugs": {
    "url": "https://github.com/kriskowal/pop-compare/issues"
  },
  "homepage": "https://github.com/kriskowal/pop-compare",
  "devDependencies": {
    "jasminum": "0.0.4"
  },
  "readme": "\n# Compare\n\nThis JavaScript package exports a comparison operator that accepts arbitrary\nobjects and performs a deep comparison operation, traversing into arrays as well\nas delegating to the compare method of either argument if one exists, favoring\nthe left side.\n\nA comparator returns a number that has the same relationship to zero as the left\nvalue has to the right.\nFor numbers, subtracting the right from the left will give you such a\ndifference value, describing both the direction and magnitude of the difference.\nA comparator for which the magnitude is not meaningful should return positive or\nnegative infinity.\n\nAs a core principle, every value is equal to itself, including NaN, making this\nsuitable for ordering arbitrary values in collections.\n\nBoxed values, like `new Number(10)` will always be unboxed before comparing.\n\nThis comparison operator does not handle equivalent object graphs with reference\ncycles at this juncture.\n\n```js\nvar compare = require(\"pop-compare\");\nexpect(compare(-1, 1)).toBe(-2);\nexpect(compare(\"abc\", \"abc\")).toBe(0);\nexpect(compare(NaN, NaN)).toBe(0);\nexpect(compare(\"a\", \"b\")).toBe(-Infinity);\n```\n\nThe compare function accepts an alternate comparator for nested comparison as\nits optional third argument.\n\n```js\nfunction dontcare() { return 0; }\nexpect(compare([10], [20], dontcare)).toBe(0);\n```\n\n## Polymorphic operator\n\nA well-planned system of objects is beautiful: a system where every meaningful\nmethod for an object has been anticipated in the design.\nInevitably, another layer of architecture introduces a new concept and with it\nthe temptation to monkey-patch, dunk-punch, or otherwise cover-up the omission.\nBut reaching backward in time, up through the layers of architecture doesn't\nalways compose well, when different levels introduce concepts of the same name\nbut distinct behavior.\n\nA polymorphic operator is a function that accepts as its first argument an\nobject and varies its behavior depending on its type.\nSuch an operator has the benefit of covering for the types from higher layers of\narchitecture, but defers to the eponymous method name of types yet to be\ndefined.\n\nThe comparison operator delegates to the compare method of either the left or\nright value, favoring the left, if either implements `compare`.\n\n```js\nvar fake = { compare: function () { return -1; } };\nexpect(compare(fake, null)).toBe(-1);\n```\n\nThe result will be inverted if the right is compared to the left.\n\n```js\nvar fake = { compare: function () { return -1; } };\nexpect(compare(null, fake)).toBe(1);\n```\n\n## License and Copyright\n\nCopyright (c) 2014 Montage Studio Inc. and contributors.\nAll rights reserved.\nBSD 3-Clause license\n\n",
  "readmeFilename": "README.md",
  "_id": "pop-compare@1.0.0",
  "_from": "pop-compare@^1.0.0"
}
